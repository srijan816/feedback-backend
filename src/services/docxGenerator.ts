import {
  Document,
  Paragraph,
  TextRun,
  Table,
  TableRow,
  TableCell,
  AlignmentType,
  WidthType,
  BorderStyle,
  Packer,
  HeadingLevel,
  convertInchesToTwip,
} from 'docx';
import fs from 'fs';
import path from 'path';
import { query } from '../config/database.js';
import logger from '../utils/logger.js';

interface FeedbackData {
  student_name: string;
  position: string;
  motion: string;
  scores: Record<string, number | string>;
  qualitative_feedback: Record<string, string[]>;
  strategic_overview?: Record<string, string>;
  teacher_notes?: string;
  debate_date: Date;
}

/**
 * Generate a DOCX file for approved feedback
 * Merges original AI feedback with teacher edits
 */
export async function generateFeedbackDocx(feedbackId: number): Promise<string> {
  try {
    logger.info(`[DOCX Generator] Starting generation for feedback ${feedbackId}`);

    // Get feedback data (merge original + draft)
    const feedbackData = await getFeedbackData(feedbackId);

    // Create document
    const doc = new Document({
      sections: [
        {
          properties: {
            page: {
              margin: {
                top: convertInchesToTwip(1),
                right: convertInchesToTwip(1),
                bottom: convertInchesToTwip(1),
                left: convertInchesToTwip(1),
              },
            },
          },
          children: [
            // Title
            new Paragraph({
              text: 'DEBATE FEEDBACK REPORT',
              heading: HeadingLevel.HEADING_1,
              alignment: AlignmentType.CENTER,
              spacing: { after: 400 },
            }),

            // Metadata section
            ...createMetadataSection(feedbackData),

            // Divider
            new Paragraph({
              text: '',
              border: {
                bottom: {
                  color: '000000',
                  space: 1,
                  style: BorderStyle.SINGLE,
                  size: 6,
                },
              },
              spacing: { before: 200, after: 200 },
            }),

            // Rubric Scores Section
            new Paragraph({
              text: 'RUBRIC SCORES',
              heading: HeadingLevel.HEADING_2,
              spacing: { before: 200, after: 200 },
            }),

            // Scores table
            ...createScoresTable(feedbackData.scores),

            // Qualitative Feedback Section
            new Paragraph({
              text: 'DETAILED FEEDBACK',
              heading: HeadingLevel.HEADING_2,
              spacing: { before: 400, after: 200 },
            }),

            // Feedback points
            ...createQualitativeFeedback(feedbackData.qualitative_feedback),

            // Strategic Overview (if available)
            ...(feedbackData.strategic_overview
              ? createStrategicOverview(feedbackData.strategic_overview)
              : []),

            // Teacher's Notes (if available)
            ...(feedbackData.teacher_notes
              ? createTeacherNotes(feedbackData.teacher_notes)
              : []),

            // Footer
            new Paragraph({
              text: '',
              spacing: { before: 400 },
            }),
            new Paragraph({
              text: '_______________________________________________',
              alignment: AlignmentType.CENTER,
              spacing: { before: 200 },
            }),
            new Paragraph({
              children: [
                new TextRun({
                  text: 'Generated by: ',
                  size: 20,
                }),
                new TextRun({
                  text: 'Debate Feedback System',
                  size: 20,
                  bold: true,
                }),
              ],
              alignment: AlignmentType.CENTER,
              spacing: { before: 200 },
            }),
            new Paragraph({
              children: [
                new TextRun({
                  text: `Generated on: ${new Date().toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                  })}`,
                  size: 20,
                  italics: true,
                }),
              ],
              alignment: AlignmentType.CENTER,
            }),
          ],
        },
      ],
    });

    // Save to file
    const outputDir = path.join(process.cwd(), 'uploads', 'docx');
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    const filename = `feedback-${feedbackId}-${Date.now()}.docx`;
    const filepath = path.join(outputDir, filename);

    // Write file
    const buffer = await Packer.toBuffer(doc);
    fs.writeFileSync(filepath, buffer);

    logger.info(`[DOCX Generator] Generated DOCX: ${filepath}`);

    return filepath;
  } catch (error) {
    logger.error('[DOCX Generator] Error:', error);
    throw error;
  }
}

/**
 * Get feedback data, merging original with draft edits
 */
async function getFeedbackData(feedbackId: number): Promise<FeedbackData> {
  const result = await query(
    `SELECT
      f.*,
      s.speaker_name,
      s.speaker_position as position,
      d.motion,
      d.created_at as debate_date,
      fd.edited_scores,
      fd.edited_qualitative_feedback,
      fd.edited_strategic_overview,
      fd.teacher_notes
    FROM feedback f
    JOIN speeches s ON f.speech_id = s.id
    JOIN debates d ON s.debate_id = d.id
    LEFT JOIN feedback_drafts fd ON f.id = fd.feedback_id
    WHERE f.id = $1`,
    [feedbackId]
  );

  if (result.rows.length === 0) {
    throw new Error(`Feedback ${feedbackId} not found`);
  }

  const row = result.rows[0];

  // Parse qualitative feedback (handle both string and object)
  let originalQualitative = row.qualitative_feedback;
  if (typeof originalQualitative === 'string') {
    try {
      originalQualitative = JSON.parse(originalQualitative);
    } catch (e) {
      originalQualitative = {};
    }
  }

  // Merge original with edits (edits take precedence)
  return {
    student_name: row.speaker_name,
    position: row.position,
    motion: row.motion,
    scores: row.edited_scores || row.scores,
    qualitative_feedback: row.edited_qualitative_feedback || originalQualitative,
    strategic_overview: row.edited_strategic_overview || row.strategic_overview,
    teacher_notes: row.teacher_notes,
    debate_date: row.debate_date,
  };
}

/**
 * Create metadata section
 */
function createMetadataSection(data: FeedbackData): Paragraph[] {
  return [
    new Paragraph({
      children: [
        new TextRun({ text: 'Student: ', bold: true }),
        new TextRun(data.student_name),
      ],
      spacing: { after: 100 },
    }),
    new Paragraph({
      children: [
        new TextRun({ text: 'Position: ', bold: true }),
        new TextRun(data.position),
      ],
      spacing: { after: 100 },
    }),
    new Paragraph({
      children: [
        new TextRun({ text: 'Motion: ', bold: true }),
        new TextRun(data.motion),
      ],
      spacing: { after: 100 },
    }),
    new Paragraph({
      children: [
        new TextRun({ text: 'Date: ', bold: true }),
        new TextRun(
          new Date(data.debate_date).toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
          })
        ),
      ],
      spacing: { after: 200 },
    }),
  ];
}

/**
 * Create scores table
 */
function createScoresTable(scores: Record<string, number | string>): Paragraph[] {
  const paragraphs: Paragraph[] = [];

  // Create a simple text-based table representation
  for (const [rubric, score] of Object.entries(scores)) {
    const stars =
      typeof score === 'number'
        ? '‚≠ê'.repeat(score) + '‚òÜ'.repeat(5 - score)
        : score.toString();

    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({ text: `${rubric}: `, bold: true, size: 24 }),
          new TextRun({ text: `${score}/5  ${stars}`, size: 24 }),
        ],
        spacing: { after: 100 },
      })
    );
  }

  paragraphs.push(
    new Paragraph({
      text: '',
      spacing: { after: 200 },
    })
  );

  return paragraphs;
}

/**
 * Create qualitative feedback section
 */
function createQualitativeFeedback(
  feedback: Record<string, string[]>
): Paragraph[] {
  const paragraphs: Paragraph[] = [];

  for (const [rubric, points] of Object.entries(feedback)) {
    // Rubric name
    paragraphs.push(
      new Paragraph({
        children: [
          new TextRun({ text: `üìå ${rubric}`, bold: true, size: 24 }),
        ],
        spacing: { before: 200, after: 100 },
      })
    );

    // Feedback points
    if (Array.isArray(points)) {
      for (const point of points) {
        paragraphs.push(
          new Paragraph({
            text: `‚Ä¢ ${point}`,
            spacing: { after: 100 },
            indent: { left: convertInchesToTwip(0.25) },
          })
        );
      }
    }
  }

  return paragraphs;
}

/**
 * Create strategic overview section
 */
function createStrategicOverview(
  overview: Record<string, string>
): Paragraph[] {
  const paragraphs: Paragraph[] = [
    new Paragraph({
      text: 'STRATEGIC OVERVIEW',
      heading: HeadingLevel.HEADING_2,
      spacing: { before: 400, after: 200 },
    }),
  ];

  for (const [section, content] of Object.entries(overview)) {
    // Section title
    const sectionTitle = section
      .split('_')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');

    paragraphs.push(
      new Paragraph({
        children: [new TextRun({ text: `üéØ ${sectionTitle}`, bold: true })],
        spacing: { before: 200, after: 100 },
      })
    );

    // Section content
    paragraphs.push(
      new Paragraph({
        text: content,
        spacing: { after: 200 },
      })
    );
  }

  return paragraphs;
}

/**
 * Create teacher's notes section
 */
function createTeacherNotes(notes: string): Paragraph[] {
  return [
    new Paragraph({
      text: "TEACHER'S NOTES",
      heading: HeadingLevel.HEADING_2,
      spacing: { before: 400, after: 200 },
    }),
    new Paragraph({
      text: notes,
      spacing: { after: 200 },
    }),
  ];
}

export default { generateFeedbackDocx };
